<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial: basics &mdash; reikna 0.3.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="reikna 0.3.3 documentation" href="index.html" />
    <link rel="next" title="Tutorial: advanced topics" href="tutorial-advanced.html" />
    <link rel="prev" title="Tutorial: modules and snippets" href="tutorial-modules.html" />
 
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34054312-1']);
    _gaq.push(['_setDomainName', 'publicfields.net']);
    _gaq.push(['_trackPageview']);

    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial-advanced.html" title="Tutorial: advanced topics"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial-modules.html" title="Tutorial: modules and snippets"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">reikna 0.3.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial-basics">
<span id="tutorial-basic"></span><h1>Tutorial: basics<a class="headerlink" href="#tutorial-basics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="usage-of-computations">
<h2>Usage of computations<a class="headerlink" href="#usage-of-computations" title="Permalink to this headline">¶</a></h2>
<p>All <tt class="docutils literal"><span class="pre">reikna</span></tt> computation classes are derived from the <a class="reference internal" href="api/core.html#reikna.core.Computation" title="reikna.core.Computation"><tt class="xref py py-class docutils literal"><span class="pre">Computation</span></tt></a> class and therefore share the same API and behavior.
A computation object is an opaque typed function-like object containing all the information necessary to generate GPU kernels that implement some algorithm, along with necessary internal temporary and persistent memory buffers.
Before use it needs to be compiled by calling <a class="reference internal" href="api/core.html#reikna.core.Computation.compile" title="reikna.core.Computation.compile"><tt class="xref py py-meth docutils literal"><span class="pre">compile()</span></tt></a> for a given <a class="reference internal" href="api/cluda.html#reikna.cluda.api.Thread" title="reikna.cluda.api.Thread"><tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt></a> (thus using its associated device and queue).
This method returns a <a class="reference internal" href="api/core.html#reikna.core.computation.ComputationCallable" title="reikna.core.computation.ComputationCallable"><tt class="xref py py-class docutils literal"><span class="pre">ComputationCallable</span></tt></a> object which takes GPU arrays and scalar parameters and calls its internal kernels.</p>
</div>
<div class="section" id="computations-and-transformations">
<h2>Computations and transformations<a class="headerlink" href="#computations-and-transformations" title="Permalink to this headline">¶</a></h2>
<p>One often needs to perform some simple processing of the input or output values of a computation.
This can be scaling, splitting complex values into components, padding, and so on.
Some of these operations require additional memory to store intermediate results, and all of them involve additional overhead of calling the kernel, and passing values to and from the device memory.
<tt class="docutils literal"><span class="pre">Reikna</span></tt> porvides an API to define such transformations and attach them to &#8220;core&#8221; computations, effectively compiling the transformation code into the main kernel(s), thus avoiding all these drawbacks.</p>
</div>
<div class="section" id="transformation-tree">
<h2>Transformation tree<a class="headerlink" href="#transformation-tree" title="Permalink to this headline">¶</a></h2>
<p>Before talking about transformations themselves, we need to take a closer look at the computation signatures.
Every <a class="reference internal" href="api/core.html#reikna.core.Computation" title="reikna.core.Computation"><tt class="xref py py-class docutils literal"><span class="pre">Computation</span></tt></a> object has a <a class="reference internal" href="api/core.html#reikna.core.Computation.signature" title="reikna.core.Computation.signature"><tt class="xref py py-attr docutils literal"><span class="pre">signature</span></tt></a> attribute containing <tt class="docutils literal"><span class="pre">funcsigs.Signature</span></tt> object.
It is the same signature object as can be exctracted from any Python function using <tt class="docutils literal"><span class="pre">funcsigs.signature</span></tt> function (or <tt class="docutils literal"><span class="pre">inspect.signature</span></tt> from the standard library for Python &gt;= 3.3).
When the computation object is compiled, the resulting callable will have this exact signature.</p>
<p>The base signature for any computation can be found in its documentation (and, sometimes, can depend on the arguments passed to its constructor &#8212; see, for example, <a class="reference internal" href="api/computations.html#reikna.pureparallel.PureParallel" title="reikna.pureparallel.PureParallel"><tt class="xref py py-class docutils literal"><span class="pre">PureParallel</span></tt></a>).
The signature can change if a user connects transformations to some parameter via <a class="reference internal" href="api/core.html#reikna.core.Computation.connect" title="reikna.core.Computation.connect"><tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt></a>; in this case the <a class="reference internal" href="api/core.html#reikna.core.Computation.signature" title="reikna.core.Computation.signature"><tt class="xref py py-attr docutils literal"><span class="pre">signature</span></tt></a> attribute will change accordingly.</p>
<p>All attached transformations form a tree with roots being the base parameters computation has right after creation, and leaves forming the user-visible signature, which the compiled <a class="reference internal" href="api/core.html#reikna.core.computation.ComputationCallable" title="reikna.core.computation.ComputationCallable"><tt class="xref py py-class docutils literal"><span class="pre">ComputationCallable</span></tt></a> will have.</p>
<p>As an example, let us consider a pure parallel computation object with one output, two inputs and a scalar parameter, which performs the calculation <tt class="docutils literal"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">in1</span> <span class="pre">+</span> <span class="pre">in2</span> <span class="pre">+</span> <span class="pre">param</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">reikna</span> <span class="kn">import</span> <span class="n">cluda</span>
<span class="kn">from</span> <span class="nn">reikna.cluda</span> <span class="kn">import</span> <span class="n">Snippet</span>
<span class="kn">from</span> <span class="nn">reikna.core</span> <span class="kn">import</span> <span class="n">Transformation</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">reikna.pureparallel</span> <span class="kn">import</span> <span class="n">PureParallel</span>
<span class="kn">import</span> <span class="nn">reikna.transformations</span> <span class="kn">as</span> <span class="nn">transformations</span>

<span class="n">arr_t</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="n">carr_t</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>

<span class="n">comp</span> <span class="o">=</span> <span class="n">PureParallel</span><span class="p">(</span>
    <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s">&#39;out&#39;</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">carr_t</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">)),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s">&#39;in1&#39;</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">carr_t</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s">&#39;in2&#39;</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">carr_t</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)),</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="s">&#39;param&#39;</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))],</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    int idx = ${idxs[0]};</span>
<span class="sd">    ${out.store_idx}(</span>
<span class="sd">        idx, ${in1.load_idx}(idx) + ${in2.load_idx}(idx) + ${param});</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The details of creating the computation itself are not important for this example; they are provided here just for the sake of completeness.
The initial transformation tree of <tt class="docutils literal"><span class="pre">comp</span></tt> object looks like:</p>
<div class="highlight-python"><pre>   | out   | &gt;&gt;
&gt;&gt; | in1   |
&gt;&gt; | in2   |
&gt;&gt; | param |</pre>
</div>
<p>Here the insides of <tt class="docutils literal"><span class="pre">||</span></tt> are the base computation (the one defined by the developer), and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> denote inputs and outputs provided by the user.
The computation signature is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">))</span>
<span class="go">out:Annotation(Type(complex64, shape=(128,), strides=(8,)), role=&#39;o&#39;)</span>
<span class="go">in1:Annotation(Type(complex64, shape=(128,), strides=(8,)), role=&#39;i&#39;)</span>
<span class="go">in2:Annotation(Type(complex64, shape=(128,), strides=(8,)), role=&#39;i&#39;)</span>
<span class="go">param:Annotation(float32)</span>
</pre></div>
</div>
<p>Now let us attach the transformation to the output which will split it into two halves: <tt class="docutils literal"><span class="pre">out1</span> <span class="pre">=</span> <span class="pre">out</span> <span class="pre">/</span> <span class="pre">2</span></tt>, <tt class="docutils literal"><span class="pre">out2</span> <span class="pre">=</span> <span class="pre">out</span> <span class="pre">/</span> <span class="pre">2</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tr</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">split_complex</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">out</span><span class="p">)</span>
<span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">out1</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
</pre></div>
</div>
<p>We have used the pre-created transformation here for simplicity; writing custom transformations is described in <a class="reference internal" href="tutorial-advanced.html#tutorial-advanced-transformation"><em>Writing a transformation</em></a>.</p>
<p>In addition, we want <tt class="docutils literal"><span class="pre">in2</span></tt> to be scaled before being passed to the main computation.
To achieve this, we connect the scaling transformation to it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tr</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">scale_param</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">in2</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">in2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">in2_prime</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">param2</span><span class="o">=</span><span class="n">tr</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
</pre></div>
</div>
<p>The transformation tree now looks like:</p>
<div class="highlight-python"><pre>                     | out   | ----&gt; out1 &gt;&gt;
                     |       |   \-&gt; out2 &gt;&gt;
                  &gt;&gt; | in1   |
&gt;&gt; in2_prime ------&gt; | in2   |
&gt;&gt; param2 ----/      |       |
                     | param |</pre>
</div>
<p>As can be seen, nothing has changed from the base computation&#8217;s point of view: it still gets the same inputs and outputs to the same array.
But user-supplied parameters (<tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>) have changed, which can be also seen in the value of the <a class="reference internal" href="api/core.html#reikna.core.Computation.signature" title="reikna.core.Computation.signature"><tt class="xref py py-attr docutils literal"><span class="pre">signature</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">))</span>
<span class="go">out1:Annotation(Type(float32, shape=(128,), strides=(4,)), role=&#39;o&#39;)</span>
<span class="go">out2:Annotation(Type(float32, shape=(128,), strides=(4,)), role=&#39;o&#39;)</span>
<span class="go">in1:Annotation(Type(complex64, shape=(128,), strides=(8,)), role=&#39;i&#39;)</span>
<span class="go">in2_prime:Annotation(Type(complex64, shape=(128,), strides=(8,)), role=&#39;i&#39;)</span>
<span class="go">param2:Annotation(float32)</span>
<span class="go">param:Annotation(float32)</span>
</pre></div>
</div>
<p>Notice that the order of the final signature is obtained by traversing the transformation tree depth-first, starting from the base parameters.
For more details see the note in the documentation for <a class="reference internal" href="api/core.html#reikna.core.Computation.connect" title="reikna.core.Computation.connect"><tt class="xref py py-meth docutils literal"><span class="pre">connect()</span></tt></a>.</p>
<p>The resulting computation returns the value <tt class="docutils literal"><span class="pre">in1</span> <span class="pre">+</span> <span class="pre">(in2_prime</span> <span class="pre">*</span> <span class="pre">param2)</span> <span class="pre">+</span> <span class="pre">param</span></tt> split in half.
In order to run it, we have to compile it first.
When <tt class="docutils literal"><span class="pre">prepare_for</span></tt> is called, the data types and shapes of the given arguments will be propagated to the roots and used to prepare the original computation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">api</span> <span class="o">=</span> <span class="n">cluda</span><span class="o">.</span><span class="n">ocl_api</span><span class="p">()</span>
<span class="n">thr</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>

<span class="n">in1_t</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">in1</span>
<span class="n">in2p_t</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">in2_prime</span>

<span class="n">out1</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">out1</span><span class="p">)</span>
<span class="n">out2</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">out2</span><span class="p">)</span>
<span class="n">in1</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">in1_t</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in1_t</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
<span class="n">in2_prime</span> <span class="o">=</span> <span class="n">thr</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">in2p_t</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2p_t</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

<span class="n">c_comp</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">thr</span><span class="p">)</span>
<span class="n">c_comp</span><span class="p">(</span><span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">in1</span><span class="p">,</span> <span class="n">in2_prime</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transformation-restrictions">
<h2>Transformation restrictions<a class="headerlink" href="#transformation-restrictions" title="Permalink to this headline">¶</a></h2>
<p>There are some limitations of the transformation mechanics:</p>
<ol class="arabic simple">
<li>Transformations are purely parallel, that is they cannot use local memory.
In fact, they are very much like <a class="reference internal" href="api/computations.html#reikna.pureparallel.PureParallel" title="reikna.pureparallel.PureParallel"><tt class="xref py py-class docutils literal"><span class="pre">PureParallel</span></tt></a> computations,
except that the indices they use are defined by the main computation,
and not set by the GPU driver.</li>
<li>External endpoints of the output transformations cannot point to existing nodes in the transformation tree.
This is the direct consequence of the first limitation &#8212; it would unavoidably create races between memory writes from different branches.
On the other hand, input transformations can be safely connected to existing nodes, including base nodes (although note that inputs are not cached; so even if you load twice from the same index of the same input node, the global memory will be queried twice).</li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial: basics</a><ul>
<li><a class="reference internal" href="#usage-of-computations">Usage of computations</a></li>
<li><a class="reference internal" href="#computations-and-transformations">Computations and transformations</a></li>
<li><a class="reference internal" href="#transformation-tree">Transformation tree</a></li>
<li><a class="reference internal" href="#transformation-restrictions">Transformation restrictions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tutorial-modules.html"
                        title="previous chapter">Tutorial: modules and snippets</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tutorial-advanced.html"
                        title="next chapter">Tutorial: advanced topics</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial-basic.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tutorial-advanced.html" title="Tutorial: advanced topics"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial-modules.html" title="Tutorial: modules and snippets"
             >previous</a> |</li>
        <li><a href="index.html">reikna 0.3.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Bogdan Opanchuk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>